/*
 *  OpenSCAD (www.openscad.org)
 *  Copyright (C) 2021      Konstantin Podsvirov <konstantin@podsvirov.pro>
 *         Povray 2024      Folkert van Heusden  <mail@vanheusden.com>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  As a special exception, you have permission to link this program
 *  with the CGAL library and distribute executables, as long as you
 *  follow the requirements of the GNU GPL in regard to all of the
 *  software in the executable aside from CGAL.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#include "export.h"

#include "PolySet.h"
#include "PolySetUtils.h"


void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo)
{
  auto ps = PolySetUtils::getGeometryAsPolySet(geom);
  if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
    ps = createSortedPolySet(*ps);
  }

  output << "// Generated by OpenSCAD!\n";
  output << "// Source file: " << exportInfo.sourceFileName << "\n\n";

  output << "#version 3.7;\n";
  output << "global_settings { assumed_gamma 1.0 }\n";
  output << "#declare MATERIAL=finish { specular 0.5 roughness 0.001 reflection{0 0.63 fresnel} ambient 0 diffuse 0.6 conserve_energy }\n";
  output << "#declare MATERIAL_INT=interior{ior 1.32}\n";

  auto has_color = !ps->color_indices.empty();

  double avg_x = 0;
  double avg_y = 0;
  double avg_z = 0;
  double tsd_x = 0;
  double tsd_y = 0;
  double tsd_z = 0;
  size_t avg_n = 0;

  for (size_t pi=0; pi<ps->indices.size(); pi++) {
    const auto &t = ps->indices.at(pi);
    output << "polygon { " << t.size() + 1 << ", \n";
    for (size_t i=0; i<t.size(); i++) {
      if (i)
        output << ", ";
      output << "<" << ps->vertices[t.at(i)].x() << ", " << -ps->vertices[t.at(i)].y() << ", " << ps->vertices[t.at(i)].z() << ">";
      avg_x += ps->vertices[t.at(i)].x();
      avg_y += -ps->vertices[t.at(i)].y();
      avg_z += ps->vertices[t.at(i)].z();
      tsd_x += ps->vertices[t.at(i)].x() * ps->vertices[t.at(i)].x();
      tsd_y += ps->vertices[t.at(i)].y() * ps->vertices[t.at(i)].y();
      tsd_z += ps->vertices[t.at(i)].z() * ps->vertices[t.at(i)].z();
      avg_n++;
    }
    double r = 1.0, g = 1.0, b = 1.0, a = 0.0;
    if (has_color) {
      auto color_index = ps->color_indices[pi];
      if (color_index >= 0) {
        auto color = ps->colors[color_index];
        r = std::clamp(double(color[0]), 0., 1.);
        g = std::clamp(double(color[1]), 0., 1.);
        b = std::clamp(double(color[2]), 0., 1.);
        a = std::clamp(1.0 - color[3], 0., 1.);
      }
    }
    if (r == 0 && g == 0 && b == 0)  // work around for black objects in 5185
      g = 1.0;
    output << ", <" << ps->vertices[t.at(0)].x() << ", " << -ps->vertices[t.at(0)].y() << ", " << ps->vertices[t.at(0)].z() << ">";
    output << "\n";
    output << "texture { pigment { color rgbf <" << r << ", " << g << ", " << b << ", " << a << "> } }\n";
    output << "finish { MATERIAL } interior { MATERIAL_INT }\n";
    output << "}\n";
  }

  double center_x = avg_x / avg_n;
  double center_y = avg_y / avg_n;
  double center_z = avg_z / avg_n;

  double sd_x = sqrt(tsd_x / avg_n - pow(center_x, 2.));
  double sd_y = sqrt(tsd_y / avg_n - pow(center_y, 2.));
  double sd_z = sqrt(tsd_z / avg_n - pow(center_z, 2.));
  double dist = pow(sd_x * sd_x + sd_y * sd_y + sd_z * sd_z, 1/3.);

  double l_x = center_x + sd_x * 5;  // '5' is chosen arbitrarily
  double l_y = center_y + sd_y * 5;
  double l_z = center_z + sd_z * 5;

  std::vector<double> lx { -l_x, 0, +l_x };
  std::vector<double> ly { -l_y, 0, +l_y };
  std::vector<double> lz { -l_z, 0, +l_z };

  constexpr const double brightness = 0.2;  // 1.0 is way too bright

  for(auto cur_lx: lx) {
	  for(auto cur_ly: ly) {
		  for(auto cur_lz: lz)
			  output << "light_source { <" << cur_lx << ", " << cur_ly << ", " << cur_lz << "> color rgb <" << brightness << ", " << brightness << ", " << brightness << "> }\n";
	  }
  }

  output << "camera { look_at <0, 0, 0> location <0, " << dist * 15 << ", 0> sky <0, 0, 1> rotate <55, clock * 3, clock - 25> }\n";
  output << "#include \"rad_def.inc\"\n";
  output << "global_settings { photons { count 20000 autostop 0 jitter .4 } radiosity { Rad_Settings(Radiosity_Normal, off, off) } }\n";
}
