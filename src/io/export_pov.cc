/*
 *  OpenSCAD (www.openscad.org)
 *  Copyright (C) 2021      Konstantin Podsvirov <konstantin@podsvirov.pro>
 *         Povray 2024      Folkert van Heusden  <mail@vanheusden.com>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  As a special exception, you have permission to link this program
 *  with the CGAL library and distribute executables, as long as you
 *  follow the requirements of the GNU GPL in regard to all of the
 *  software in the executable aside from CGAL.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#include "export.h"

#include "PolySet.h"
#include "PolySetUtils.h"


void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo)
{
  auto ps = PolySetUtils::getGeometryAsPolySet(geom);
  if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
    ps = createSortedPolySet(*ps);
  }

  output << "// Generated by OpenSCAD!\n";
  output << "// Source file: " << exportInfo.sourceFileName << "\n\n";

  output << "#version 3.7;\n";
  output << "global_settings { assumed_gamma 1.0 }\n";
  output << "#declare MATERIAL=finish { specular 0.5 roughness 0.001 reflection{0 0.63 fresnel} ambient 0 diffuse 0.6 conserve_energy }\n";
  output << "#declare MATERIAL_INT=interior{ior 1.32}\n";

  auto has_color = !ps->color_indices.empty();

  double avg_x = 0;
  double avg_y = 0;
  double avg_z = 0;
  double tsd_x = 0;
  double tsd_y = 0;
  double tsd_z = 0;
  size_t avg_n = 0;

  for (size_t polygon_index=0; polygon_index<ps->indices.size(); polygon_index++) {
    const auto &polygon = ps->indices[polygon_index];
    output << "polygon { " << polygon.size() + 1 << ", \n";
    for (size_t i=0; i<polygon.size(); i++) {
      if (i)
        output << ", ";
      const auto & x = ps->vertices[polygon[i]].x();
      const auto & y = ps->vertices[polygon[i]].y();
      const auto & z = ps->vertices[polygon[i]].z();
      output << "<" << x << ", " << y << ", " << z << ">";
      avg_x += x;
      avg_y += y;
      avg_z += z;
      tsd_x += x * x;
      tsd_y += y * y;
      tsd_z += z * z;
      avg_n++;
    }
    output << ", <" << ps->vertices[polygon[0]].x() << ", " << ps->vertices[polygon[0]].y() << ", " << ps->vertices[polygon[0]].z() << ">";
    float r = 1.0, g = 1.0, b = 1.0, a = 0.0;
    if (has_color) {
      auto color_index = ps->color_indices[polygon_index];
      if (color_index >= 0) {
        auto color = ps->colors[color_index];
        r = float(color[0]);
        g = float(color[1]);
        b = float(color[2]);
        a = 1.0 - color[3];
      }
    }
    if (r == 0 && g == 0 && b == 0)  // work around for black objects in 5185
      g = 1.0;
    output << "\n";
    output << "texture { pigment { color rgbf <" << r << ", " << g << ", " << b << ", " << a << "> } }\n";
    output << "finish { MATERIAL } interior { MATERIAL_INT }\n";
    output << "}\n";
  }

  double center_x = avg_x / avg_n;
  double center_y = avg_y / avg_n;
  double center_z = avg_z / avg_n;

  double sd_x = sqrt(tsd_x / avg_n - pow(center_x, 2.));
  double sd_y = sqrt(tsd_y / avg_n - pow(center_y, 2.));
  double sd_z = sqrt(tsd_z / avg_n - pow(center_z, 2.));
  double dist = pow(sd_x * sd_x + sd_y * sd_y + sd_z * sd_z, 1/3.);

  double light_vector_x = center_x + sd_x * 5;  // '5' is chosen arbitrarily
  double light_vector_y = center_y + sd_y * 5;
  double light_vector_z = center_z + sd_z * 5;

  std::vector<double> lx { -light_vector_x, 0, +light_vector_x };
  std::vector<double> ly { -light_vector_y, 0, +light_vector_y };
  std::vector<double> lz { -light_vector_z, 0, +light_vector_z };

  constexpr float brightness = 0.2;  // 1.0 is way too bright

  for(auto cur_lx: lx) {
	  for(auto cur_ly: ly) {
		  for(auto cur_lz: lz)
			  output << "light_source { <" << cur_lx << ", " << cur_ly << ", " << cur_lz << "> color rgb <" << brightness << ", " << brightness << ", " << brightness << "> }\n";
	  }
  }
  output << "camera { look_at <0, 0, 0> location <0, " << -dist * 15 << ", 0> up <0, 0, 1> right <1, 0, 0> sky <0, 0, 1> rotate <-55, clock * 3, clock + 25> }\n";
  output << "#include \"rad_def.inc\"\n";
  output << "global_settings { photons { count 20000 autostop 0 jitter .4 } radiosity { Rad_Settings(Radiosity_Normal, off, off) } }\n";
}
